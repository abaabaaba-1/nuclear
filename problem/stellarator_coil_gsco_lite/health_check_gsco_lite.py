#!/usr/bin/env python3

import sys
import os
import json
import logging
from pathlib import Path

import numpy as np
import matplotlib.pyplot as plt

project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

from model.MOLLM import ConfigLoader
from algorithm.base import Item
from problem.stellarator_coil_gsco_lite.evaluator import SimpleGSCOEvaluator, generate_initial_population


def run_health_check(n_samples: int = 200, seed: int = 123) -> None:
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )
    logger = logging.getLogger("GSCOHealthCheck")

    config_rel_path = "stellarator_coil_gsco_lite/config.yaml"
    yaml_path = project_root / "problem" / config_rel_path

    if not yaml_path.is_file():
        logger.error(f"Config file not found: {yaml_path}")
        return

    try:
        import yaml

        with open(yaml_path, "r") as f:
            raw_cfg = yaml.safe_load(f) or {}
        objective_ranges = raw_cfg.get("objective_ranges", {})
    except Exception as e:
        logger.warning(f"Failed to load objective_ranges from YAML: {e}")
        objective_ranges = {}

    logger.info("=" * 70)
    logger.info("GSCO-Lite Benchmark Health Check")
    logger.info("=" * 70)
    logger.info(f"Config path: {yaml_path}")
    logger.info(f"Requested samples: {n_samples}")
    logger.info(f"Random seed: {seed}")
    logger.info("Current objective_ranges (from YAML):")
    for k, v in objective_ranges.items():
        logger.info(f"  {k}: {v}")

    config = ConfigLoader(config_rel_path)
    evaluator = SimpleGSCOEvaluator(config)

    # Property list for this benchmark: align with goals in config if available
    goals = config.get("goals", ["f_B", "f_S", "I_max"])

    logger.info("Generating random configurations using generate_initial_population...")
    pop = generate_initial_population(config, seed=seed)
    if not pop:
        logger.error("No candidates generated by generate_initial_population.")
        return

    pop = pop[:n_samples]
    logger.info(f"Using {len(pop)} candidates for health check.")

    # Create Items with the appropriate property_list so that evaluator.assign_results works
    items = [Item(value=cfg, property_list=goals) for cfg in pop]

    logger.info("Evaluating candidates (this may take some time)...")
    evaluated_items, log_dict = evaluator.evaluate(items)

    if not evaluated_items:
        logger.error("No valid items after evaluation.")
        return

    logger.info("Evaluation summary:")
    logger.info(f"  Valid items:   {len(evaluated_items)}")
    logger.info(f"  Invalid items: {log_dict.get('invalid_num', 0)}")
    logger.info(f"  Repeated items:{log_dict.get('repeated_num', 0)}")

    def collect_raw(obj_name: str):
        """Collect raw objective values from evaluated Items."""
        raw = []
        for it in evaluated_items:
            if getattr(it, "property", None) and obj_name in it.property:
                raw.append(it.property[obj_name])
        return np.array(raw)

    def print_stats(name: str, raw: np.ndarray, norm: np.ndarray) -> None:
        if raw.size == 0:
            logger.warning(f"No data for objective {name}.")
            return
        logger.info("-" * 70)
        logger.info(f"Objective: {name}")
        logger.info(f"  Raw   min / max / mean: {raw.min():.4e}  /  {raw.max():.4e}  /  {raw.mean():.4e}")
        if norm.size > 0:
            logger.info(f"  Norm  min / max / mean: {norm.min():.4f}  /  {norm.max():.4f}  /  {norm.mean():.4f}")
            eps = 1e-8
            frac_low = float((norm <= eps).mean())
            frac_high = float((norm >= 1.0 - eps).mean())
            logger.info(f"  Clip rate @0: {frac_low * 100:.2f}%  (values at lower bound)")
            logger.info(f"  Clip rate @1: {frac_high * 100:.2f}%  (values at upper bound)")
        else:
            logger.warning("  No normalized values computed.")

    # Collect raw values
    f_B_raw = collect_raw("f_B")
    f_S_raw = collect_raw("f_S")
    I_max_raw = collect_raw("I_max")

    # Use evaluator's own transform_objectives to compute normalized values
    f_B_norm = evaluator.transform_objectives("f_B", f_B_raw.copy()) if f_B_raw.size > 0 else np.array([])
    f_S_norm = evaluator.transform_objectives("f_S", f_S_raw.copy()) if f_S_raw.size > 0 else np.array([])
    I_max_norm = evaluator.transform_objectives("I_max", I_max_raw.copy()) if I_max_raw.size > 0 else np.array([])

    logger.info("\nRaw and normalized statistics (including clipping rates):")
    print_stats("f_B", f_B_raw, f_B_norm)
    print_stats("f_S", f_S_raw, f_S_norm)
    print_stats("I_max", I_max_raw, I_max_norm)

    plots_dir = project_root / "problem" / "stellarator_coil_gsco_lite" / "plots"
    plots_dir.mkdir(parents=True, exist_ok=True)

    if f_B_raw.size > 0:
        plt.figure()
        plt.hist(f_B_raw, bins=20, edgecolor="black")
        plt.xlabel("f_B [T^2 m^2]")
        plt.ylabel("count")
        plt.title("GSCO-Lite f_B (raw)")
        plt.tight_layout()
        plt.savefig(plots_dir / "gsco_f_B_raw_hist.png")
        plt.close()

    if f_B_norm.size > 0:
        plt.figure()
        plt.hist(f_B_norm, bins=20, range=(0.0, 1.0), edgecolor="black")
        plt.xlabel("f_B (normalized)")
        plt.ylabel("count")
        plt.title("GSCO-Lite f_B (normalized)")
        plt.tight_layout()
        plt.savefig(plots_dir / "gsco_f_B_norm_hist.png")
        plt.close()

    if f_S_raw.size > 0:
        plt.figure()
        plt.hist(f_S_raw, bins=20, edgecolor="black")
        plt.xlabel("f_S [active cells]")
        plt.ylabel("count")
        plt.title("GSCO-Lite f_S (raw)")
        plt.tight_layout()
        plt.savefig(plots_dir / "gsco_f_S_raw_hist.png")
        plt.close()

    if f_S_norm.size > 0:
        plt.figure()
        plt.hist(f_S_norm, bins=20, range=(0.0, 1.0), edgecolor="black")
        plt.xlabel("f_S (normalized)")
        plt.ylabel("count")
        plt.title("GSCO-Lite f_S (normalized)")
        plt.tight_layout()
        plt.savefig(plots_dir / "gsco_f_S_norm_hist.png")
        plt.close()

    if I_max_raw.size > 0:
        plt.figure()
        plt.hist(I_max_raw, bins=20, edgecolor="black")
        plt.xlabel("I_max [MA]")
        plt.ylabel("count")
        plt.title("GSCO-Lite I_max (raw)")
        plt.tight_layout()
        plt.savefig(plots_dir / "gsco_I_max_raw_hist.png")
        plt.close()

    if I_max_norm.size > 0:
        plt.figure()
        plt.hist(I_max_norm, bins=20, range=(0.0, 1.0), edgecolor="black")
        plt.xlabel("I_max (normalized)")
        plt.ylabel("count")
        plt.title("GSCO-Lite I_max (normalized)")
        plt.tight_layout()
        plt.savefig(plots_dir / "gsco_I_max_norm_hist.png")
        plt.close()

    logger.info("=" * 70)
    logger.info("Health check finished.")
    logger.info("If clip rates are very high (e.g., >50%), consider recalibrating objective_ranges.")


if __name__ == "__main__":
    default_samples = 200
    default_seed = 123

    if len(sys.argv) > 1:
        try:
            default_samples = int(sys.argv[1])
        except Exception:
            pass
    if len(sys.argv) > 2:
        try:
            default_seed = int(sys.argv[2])
        except Exception:
            pass

    run_health_check(n_samples=default_samples, seed=default_seed)
